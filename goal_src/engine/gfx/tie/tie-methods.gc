;;-*-Lisp-*-
(in-package goal)

;; name: tie-methods.gc
;; name in dgo: tie-methods
;; dgos: GAME, ENGINE

(defun tie-init-buffers ((arg0 dma-buffer))
  "Initialize the TIE buckets.
  Note: the buffer passed in here is _not_ used.
  this function should be called _after_ all TIE drawing is done.
  It will skip setup if there is nothing drawn."
  
  ;; the TIE buckets are only used by TIE - so we can safely splice things at the beginning/end without
  ;; messing things up.
  (let ((gp-0 (-> *display* frames (-> *display* on-screen) frame bucket-group (bucket-id tie-0))))
    ;; only if we have something in the bucket.
    (when (!= gp-0 (-> gp-0 last))
      (let* ((s5-0 (-> *display* frames (-> *display* on-screen) frame global-buf))
             (s4-1 (-> s5-0 base))
             )
        ;; add initialization data
        (tie-init-engine
          s5-0
          (new 'static 'gs-test :atst (gs-atest not-equal) :zte #x1 :ztst (gs-ztest greater-equal))
          0
          )
        ;; patch to the start
        (let ((v1-8 (the-as object (-> s5-0 base))))
          (set! (-> (the-as dma-packet v1-8) dma) (new 'static 'dma-tag :id (dma-tag-id next) :addr (-> gp-0 next)))
          (set! (-> (the-as dma-packet v1-8) vif0) (new 'static 'vif-tag))
          (set! (-> (the-as dma-packet v1-8) vif1) (new 'static 'vif-tag))
          (set! (-> s5-0 base) (&+ (the-as pointer v1-8) 16))
          )
        (set! (-> gp-0 next) (the-as uint s4-1))
        )
      )
    )
  
  (let ((gp-1 (-> *display* frames (-> *display* on-screen) frame bucket-group (bucket-id tie-0))))
    ;; only if we have something in teh bucket
    (when (!= gp-1 (-> gp-1 last))
      (let* ((s4-2 (-> *display* frames (-> *display* on-screen) frame global-buf))
             (s5-1 (-> s4-2 base))
             )
        ;; add the end data at the end.
        (tie-end-buffer s4-2)
        (let ((v1-19 (-> s4-2 base)))
          (let ((a0-17 (the-as object (-> s4-2 base))))
            (set! (-> (the-as dma-packet a0-17) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
            (set! (-> (the-as dma-packet a0-17) vif0) (new 'static 'vif-tag))
            (set! (-> (the-as dma-packet a0-17) vif1) (new 'static 'vif-tag))
            (set! (-> s4-2 base) (&+ (the-as pointer a0-17) 16))
            )
          (set! (-> (the-as (pointer uint32) (-> gp-1 last)) 1) (the-as uint s5-1))
          (set! (-> gp-1 last) (the-as (pointer dma-tag) v1-19))
          )
        )
      )
    )
  
  ;; same as above, but for level 1's tie.
  (let ((gp-2 (-> *display* frames (-> *display* on-screen) frame bucket-group (bucket-id tie-1))))
    (when (!= gp-2 (-> gp-2 last))
      (let* ((s5-2 (-> *display* frames (-> *display* on-screen) frame global-buf))
             (s4-4 (-> s5-2 base))
             )
        (tie-init-engine
          s5-2
          (new 'static 'gs-test :atst (gs-atest not-equal) :zte #x1 :ztst (gs-ztest greater-equal))
          0
          )
        (let ((v1-28 (the-as object (-> s5-2 base))))
          (set! (-> (the-as dma-packet v1-28) dma) (new 'static 'dma-tag :id (dma-tag-id next) :addr (-> gp-2 next)))
          (set! (-> (the-as dma-packet v1-28) vif0) (new 'static 'vif-tag))
          (set! (-> (the-as dma-packet v1-28) vif1) (new 'static 'vif-tag))
          (set! (-> s5-2 base) (&+ (the-as pointer v1-28) 16))
          )
        (set! (-> gp-2 next) (the-as uint s4-4))
        )
      )
    )
  (let ((gp-3 (-> *display* frames (-> *display* on-screen) frame bucket-group (bucket-id tie-1))))
    (when (!= gp-3 (-> gp-3 last))
      (let* ((s4-5 (-> *display* frames (-> *display* on-screen) frame global-buf))
             (s5-3 (-> s4-5 base))
             )
        (tie-end-buffer s4-5)
        (let ((v1-39 (-> s4-5 base)))
          (let ((a0-36 (the-as object (-> s4-5 base))))
            (set! (-> (the-as dma-packet a0-36) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
            (set! (-> (the-as dma-packet a0-36) vif0) (new 'static 'vif-tag))
            (set! (-> (the-as dma-packet a0-36) vif1) (new 'static 'vif-tag))
            (set! (-> s4-5 base) (&+ (the-as pointer a0-36) 16))
            )
          (set! (-> (the-as (pointer uint32) (-> gp-3 last)) 1) (the-as uint s5-3))
          (set! (-> gp-3 last) (the-as (pointer dma-tag) v1-39))
          )
        )
      )
    )
  
  #|
  ;; level 0's tie near
  (let ((gp-4 (-> *display* frames (-> *display* on-screen) frame bucket-group (bucket-id tie-near-0))))
    (when (!= gp-4 (-> gp-4 last))
      (let* ((s5-4 (-> *display* frames (-> *display* on-screen) frame global-buf))
             (s4-7 (-> s5-4 base))
             )
        (tie-near-init-engine
          s5-4
          (new 'static 'gs-test
               :ate #x1
               :atst (gs-atest greater-equal)
               :aref #x26
               :zte #x1
               :ztst (gs-ztest greater-equal)
               )
          0
          )
        (let ((v1-48 (the-as object (-> s5-4 base))))
          (set! (-> (the-as dma-packet v1-48) dma) (new 'static 'dma-tag :id (dma-tag-id next) :addr (-> gp-4 next)))
          (set! (-> (the-as dma-packet v1-48) vif0) (new 'static 'vif-tag))
          (set! (-> (the-as dma-packet v1-48) vif1) (new 'static 'vif-tag))
          (set! (-> s5-4 base) (&+ (the-as pointer v1-48) 16))
          )
        (set! (-> gp-4 next) (the-as uint s4-7))
        )
      )
    )
  (let ((gp-5 (-> *display* frames (-> *display* on-screen) frame bucket-group (bucket-id tie-near-0))))
    (when (!= gp-5 (-> gp-5 last))
      (let* ((s4-8 (-> *display* frames (-> *display* on-screen) frame global-buf))
             (s5-5 (-> s4-8 base))
             )
        (tie-near-end-buffer s4-8)
        (let ((v1-59 (-> s4-8 base)))
          (let ((a0-55 (the-as object (-> s4-8 base))))
            (set! (-> (the-as dma-packet a0-55) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
            (set! (-> (the-as dma-packet a0-55) vif0) (new 'static 'vif-tag))
            (set! (-> (the-as dma-packet a0-55) vif1) (new 'static 'vif-tag))
            (set! (-> s4-8 base) (&+ (the-as pointer a0-55) 16))
            )
          (set! (-> (the-as (pointer uint32) (-> gp-5 last)) 1) (the-as uint s5-5))
          (set! (-> gp-5 last) (the-as (pointer dma-tag) v1-59))
          )
        )
      )
    )
  
  ;; level 1's tie near
  (let ((gp-6 (-> *display* frames (-> *display* on-screen) frame bucket-group (bucket-id tie-near-1))))
    (when (!= gp-6 (-> gp-6 last))
      (let* ((s5-6 (-> *display* frames (-> *display* on-screen) frame global-buf))
             (s4-10 (-> s5-6 base))
             )
        (tie-near-init-engine
          s5-6
          (new 'static 'gs-test
               :ate #x1
               :atst (gs-atest greater-equal)
               :aref #x26
               :zte #x1
               :ztst (gs-ztest greater-equal)
               )
          0
          )
        (let ((v1-68 (the-as object (-> s5-6 base))))
          (set! (-> (the-as dma-packet v1-68) dma) (new 'static 'dma-tag :id (dma-tag-id next) :addr (-> gp-6 next)))
          (set! (-> (the-as dma-packet v1-68) vif0) (new 'static 'vif-tag))
          (set! (-> (the-as dma-packet v1-68) vif1) (new 'static 'vif-tag))
          (set! (-> s5-6 base) (&+ (the-as pointer v1-68) 16))
          )
        (set! (-> gp-6 next) (the-as uint s4-10))
        )
      )
    )
  (let ((gp-7 (-> *display* frames (-> *display* on-screen) frame bucket-group (bucket-id tie-near-1))))
    (when (!= gp-7 (-> gp-7 last))
      (let* ((s4-11 (-> *display* frames (-> *display* on-screen) frame global-buf))
             (s5-7 (-> s4-11 base))
             )
        (tie-near-end-buffer s4-11)
        (let ((v1-79 (-> s4-11 base)))
          (let ((a0-74 (the-as object (-> s4-11 base))))
            (set! (-> (the-as dma-packet a0-74) dma) (new 'static 'dma-tag :id (dma-tag-id next)))
            (set! (-> (the-as dma-packet a0-74) vif0) (new 'static 'vif-tag))
            (set! (-> (the-as dma-packet a0-74) vif1) (new 'static 'vif-tag))
            (set! (-> s4-11 base) (&+ (the-as pointer a0-74) 16))
            )
          (set! (-> (the-as (pointer uint32) (-> gp-7 last)) 1) (the-as uint s5-7))
          (set! (-> gp-7 last) (the-as (pointer dma-tag) v1-79))
          )
        )
      )
    )
    |#
  0
  (none)
  )


;;;;;;;;;;;;;;;;;
;; TIE debug
;;;;;;;;;;;;;;;;;

;; most of this doesn't really do anything.

;; a ranges of instances to debug
(deftype tie-instance-debug (structure)
  ((max-instance uint32  :offset-assert   0)
   (min-instance uint32  :offset-assert   4)
   )
  :method-count-assert 9
  :size-assert         #x8
  :flag-assert         #x900000008
  )

;; unused
(define *tie* (new 'global 'tie-instance-debug))

(defun tie-debug-between ((arg0 uint) (arg1 uint))
  (set! (-> *instance-tie-work* test-id) arg1)
  (set! (-> *instance-tie-work* test-id2) arg0)
  arg0
  )

(defun tie-debug-one ((arg0 uint) (arg1 uint))
  (set! (-> *instance-tie-work* test-id) (+ arg1 -1 arg0))
  (set! (-> *instance-tie-work* test-id2) arg0)
  arg0
  )

(defun walk-tie-generic-prototypes ()
  (none)
  )

;; unused
(define *pke-hack* (new 'global 'vector))

;; draw-inline-array-instance-tie
;; draw-inline-array-prototype-tie-generic-asm
;; draw-inline-array-prototype-tie-asm
;; draw-inline-array-prototype-tie-near-asm


(defmethod login drawable-tree-instance-tie ((obj drawable-tree-instance-tie))
  (if (nonzero? (-> obj prototypes prototype-array-tie))
      (login (-> obj prototypes prototype-array-tie))
      )
  (dotimes (s5-0 (-> obj length))
    (login (-> obj data s5-0))
    )
  obj
  )

(defmethod draw drawable-tree-instance-tie ((obj drawable-tree-instance-tie) (arg0 drawable) (arg1 display-frame))
  "Add the tree to the background work list."
  ;; NOTE: for now it's commented out because nothing removes the trees yet.
  #|
  (let* ((v1-1 (-> *background-work* tie-tree-count))
         (a1-2 (-> (scratchpad-obj terrain-context) bsp lev-index))
         (a1-5 (-> *level* level a1-2))
         )
    (set! (-> *background-work* tie-trees v1-1) obj)
    (set! (-> *background-work* tie-levels v1-1) a1-5)
    )
  (+! (-> *background-work* tie-tree-count) 1)
  |#
  (none)
  )

(defmethod collect-stats drawable-tree-instance-tie ((obj drawable-tree-instance-tie))
  "Collect statistics on TIE drawing."
  
  ;; only if tie/generic ran
  (when (logtest? *vu1-enable-user* (vu1-renderer-mask tie-near tie generic))
    ;; unused?
    (-> obj data (+ (-> obj length) -1))
    
    ;; loop over all prototypes.
    ;; the drawing process will write to the prototypes to say how many of each it draws
    (let ((v1-8 (-> obj prototypes prototype-array-tie)))
      (dotimes (a0-1 (-> v1-8 length))
        ;; grap the prototype
        (let ((a1-2 (-> v1-8 array-data a0-1)))
          
          ;; GENERIC
          (when (logtest? *vu1-enable-user* (vu1-renderer-mask generic))
            ;; there are 4 arrays of fragments per prototype. Looks like we check them all for generic.
            (let ((a2-3 0)
                  (a3-0 3)
                  )
              (while (>= a3-0 a2-3)
                (let ((t0-2 (-> a1-2 generic-count a2-3))     ;; number of times this geom was drawn with generic
                      (t2-0 (-> a1-2 geometry-override a2-3)) ;; the geom that was drawn
                      )
                  (when (nonzero? t0-2)                         ;; were we drawn?
                    (let ((t1-3 (the-as object (-> t2-0 data))) ;; tie fragment array
                          (t2-1 (-> t2-0 length))               ;; number of tie fragments
                          )
                      (+! (-> *terrain-stats* tie-generic groups) 1)       ;; number of geometries drawn (unique)
                      (+! (-> *terrain-stats* tie-generic fragments) t2-1) ;; number of frags drawn (unique)
                      (+! (-> *terrain-stats* tie-generic instances) t0-2) ;; number of instances drawn (not unique)
                      
                      ;; now, collect stats per fragment
                      (dotimes (t3-9 t2-1)
                        (let ((t5-0 (* (-> (the-as tie-fragment t1-3) num-tris) t0-2)) ;; multiply by number of instances
                              (t4-5 (* (-> (the-as tie-fragment t1-3) num-dverts) t0-2))
                              )
                          (+! (-> *terrain-stats* tie-generic tris) t5-0)
                          (+! (-> *terrain-stats* tie-generic dverts) t4-5)
                          )
                        (set! t1-3 (&+ (the-as tie-fragment t1-3) 64))
                        )
                      )
                    )
                  )
                (+! a2-3 1)
                )
              )
            )
          
          ;; normal tie
          (when (logtest? *vu1-enable-user* (vu1-renderer-mask tie))
            (let ((a2-9 1) ;; looks like we never draw geom 0's with normal tie?
                  (a3-1 3)
                  )
              (while (>= a3-1 a2-9)
                (let ((t0-6 (-> a1-2 count a2-9))
                      (t2-2 (-> a1-2 geometry-override a2-9))
                      )
                  (when (nonzero? t0-6)
                    (let ((t1-8 (the-as object (-> t2-2 data)))
                          (t2-3 (-> t2-2 length))
                          )
                      (+! (-> *terrain-stats* tie groups) 1)
                      (+! (-> *terrain-stats* tie fragments) t2-3)
                      (+! (-> *terrain-stats* tie instances) t0-6)
                      (dotimes (t3-19 t2-3)
                        (let ((t5-5 (* (-> (the-as tie-fragment t1-8) num-tris) t0-6))
                              (t4-12 (* (-> (the-as tie-fragment t1-8) num-dverts) t0-6))
                              )
                          (+! (-> *terrain-stats* tie tris) t5-5)
                          (+! (-> *terrain-stats* tie dverts) t4-12)
                          )
                        (set! t1-8 (&+ (the-as tie-fragment t1-8) 64))
                        )
                      )
                    )
                  )
                (+! a2-9 1)
                )
              )
            )
          
          ;; near tie
          (when (logtest? *vu1-enable-user* (vu1-renderer-mask tie-near))
            (let ((a2-14 (-> a1-2 count 0)) ;; always geom 0.
                  (a3-2 (-> a1-2 geometry-override 0))
                  )
              (when (nonzero? a2-14)
                (let ((a1-3 (the-as object (-> a3-2 data)))
                      (a3-3 (-> a3-2 length))
                      )
                  (+! (-> *terrain-stats* tie-near groups) 1)
                  (+! (-> *terrain-stats* tie-near fragments) a3-3)
                  (+! (-> *terrain-stats* tie-near instances) a2-14)
                  (dotimes (t0-19 a3-3)
                    (let ((t2-4 (* (-> (the-as tie-fragment a1-3) num-tris) a2-14))
                          (t1-15 (* (-> (the-as tie-fragment a1-3) num-dverts) a2-14))
                          )
                      (+! (-> *terrain-stats* tie-near tris) t2-4)
                      (+! (-> *terrain-stats* tie-near dverts) t1-15)
                      )
                    (set! a1-3 (&+ (the-as tie-fragment a1-3) 64))
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  (none)
  )



(defmethod debug-draw drawable-tree-instance-tie ((obj drawable-tree-instance-tie) (arg0 drawable) (arg1 display-frame))
  (-> obj data (+ (-> obj length) -1))
  (let* ((s5-0 (-> obj prototypes prototype-array-tie))
         (s4-0 (-> s5-0 length))
         )
    (dotimes (s3-0 s4-0)
      (let ((a1-1 (-> s5-0 array-data s3-0 geometry 0)))
        (debug-draw a1-1 a1-1 arg1)
        )
      )
    )
  (none)
  )

;;;;;;;;;;;;;;;;;
;; TIE collision
;;;;;;;;;;;;;;;;;

;; note: the first three methods appear twice in the original code.

(defmethod collide-with-box drawable-tree-instance-tie ((obj drawable-tree-instance-tie) (arg0 int) (arg1 collide-list))
  (collide-with-box (-> obj data 0) (-> obj length) arg1)
  0
  (none)
  )

(defmethod collide-y-probe drawable-tree-instance-tie ((obj drawable-tree-instance-tie) (arg0 int) (arg1 collide-list))
  (collide-y-probe (-> obj data 0) (-> obj length) arg1)
  0
  (none)
  )

(defmethod collide-ray drawable-tree-instance-tie ((obj drawable-tree-instance-tie) (arg0 int) (arg1 collide-list))
  (collide-ray (-> obj data 0) (-> obj length) arg1)
  0
  (none)
  )


(defmethod collide-with-box drawable-inline-array-instance-tie ((obj drawable-inline-array-instance-tie) (arg0 int) (arg1 collide-list))
  (collide-with-box (the-as instance-tie (-> obj data)) (-> obj length) arg1)
  0
  (none)
  )

(defmethod collide-y-probe drawable-inline-array-instance-tie ((obj drawable-inline-array-instance-tie) (arg0 int) (arg1 collide-list))
  (collide-y-probe (the-as instance-tie (-> obj data)) (-> obj length) arg1)
  0
  (none)
  )

(defmethod collide-ray drawable-inline-array-instance-tie ((obj drawable-inline-array-instance-tie) (arg0 int) (arg1 collide-list))
  (collide-ray (the-as instance-tie (-> obj data)) (-> obj length) arg1)
  0
  (none)
  )

(defun tie-test-cam-restore ()
  (let ((a0-0 (new-stack-vector0))
        (a1-0 (new-stack-matrix0))
        )
    (set! (-> a0-0 x) 1246582.6)
    (set! (-> a0-0 y) 57026.02)
    (set! (-> a0-0 z) -490734.78)
    (set! (-> a0-0 w) 1.0)
    (set! (-> a1-0 vector 0 x) -0.9873)
    (set! (-> a1-0 vector 0 y) 0.0)
    (set! (-> a1-0 vector 0 z) -0.1587)
    (set! (-> a1-0 vector 0 w) 0.0)
    (set! (-> a1-0 vector 1 x) 0.0014)
    (set! (-> a1-0 vector 1 y) 0.9999)
    (set! (-> a1-0 vector 1 z) -0.0092)
    (set! (-> a1-0 vector 1 w) 0.0)
    (set! (-> a1-0 vector 2 x) 0.1587)
    (set! (-> a1-0 vector 2 y) -0.0093)
    (set! (-> a1-0 vector 2 z) -0.9872)
    (set! (-> a1-0 vector 2 w) 0.0)
    (set! (-> a1-0 vector 3 x) 0.0)
    (set! (-> a1-0 vector 3 y) 0.0)
    (set! (-> a1-0 vector 3 z) 0.0)
    (set! (-> a1-0 vector 3 w) 1.0)
    (debug-set-camera-pos-rot! a0-0 a1-0)
    )
  (send-event *camera* 'set-fov 11650.845)
  (none)
  )